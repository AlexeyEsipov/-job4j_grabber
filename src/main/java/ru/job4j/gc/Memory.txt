Создаем объект класса UserGC со следующим кодом:

public class UserGC {
    int a = 0;
    int[] ar1 = new int[245];

    public UserGC(int a) {
        this.a = a;
    }
}

Рассчитаем, сколько объект этого класса будет занимать места в памяти.
1. При создании экземпляра класса UserGC заголовок объекта займет 12 байт.
2. int a = 0;  - примитивная переменная типа int занимает 32 бит или 4 байта.
3. int[] ar1 = new int[245]; - в этой строке последовательно рассмотрим
   3.1. int[] ar1  - ссылочная переменная ar1 на объект типа массив int[] занимает в
        памяти машинное слово - если система 64-битная, то 64/8 = 8 байт, если система
        32-битная, то 32/8 = 4 байта. В моем случае это 8 байт.
   3.2. new int[]  - объект типа массив занимает в памяти 12 байт как заголовок объекта,
        плюс 4 байта (переменная типа int, в примере это 245) займет указание длины массива - помним,
        что создать массив без указания длины невозможно - JVM резервирует память
        сообразно типу и количеству ячеек массива. Итого 16 байт.
   3.3  резервирование места под 246 значений типа int -  4 * 245 = 980 байт.
4. Суммируем: 12 + 4 + 8 + 16 + (4*245) = 1020 байт.
5  Необходимо учесть выравнивание заголовков новых объектов, которое производит JVM. Суть выравнивания
    состоит в том, что новый объект всегда будет начинаться с начала машинного слова,то есть предыдущий
    хранящийся объект будет дополнен пустыми байтами до окончания текущего машинного слова - другими словами, если
    размер объекта не кратен 8, то недостающие байты будут дополнены пустыми байтами ( содержащими 0).
    В нашем случае 1020 байт не кратно 8, ближайщее кратное значение 1024, соответственно, будет добавлено
    еще 4 байта ( пустые значения - 0) до окончания машинного слова.
6. Итого размер нашего объекта будет равен 1020 + 4 = 1024 байт.

Пустой объект (без полей) состоит только из заголовка объекта - это 12 байт, плюс выравнивающие пробелы
до окончания машинного слова - в 64-битной системе это плюс 4 бита до 16 байт.

